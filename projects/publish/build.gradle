plugins {
	id "com.github.breadmoirai.github-release" version "2.2.12"
	id "com.matthewprenger.cursegradle" version "1.4.0"
	id "com.modrinth.minotaur" version "2.+"
}

def buildVersion = new File("${projectDir}/../version.txt").getText('UTF-8').trim()
def changeLog = new File("${projectDir}/changelog.md").getText('UTF-8')
ext.gameVersions = file("gameVersions.txt").getText('UTF-8').split(" ")

def githubOK = project.hasProperty("githubToken")
def curseOK = project.hasProperty("curseToken") && project.hasProperty("gameVersion")
def modrinthOK = project.hasProperty("modrinthToken") && project.hasProperty("gameVersion")

task build {}
task assemble {}

if(githubOK){
	githubRelease {
		token project.githubToken // This is your personal access token with Repo permissions
							 // You get this from your user settings > developer settings > Personal Access Tokens
		owner project.githubOwner // default is the last part of your group. Eg group: "com.github.breadmoirai" => owner: "breadmoirai"
		repo project.githubRepo // by default this is set to your project name
		tagName "v${buildVersion}" // by default this is set to "v${project.version}"
		targetCommitish "master" // by default this is set to "master"
		releaseName "${project.releaseName} ${buildVersion}"
		body changeLog // by default this is empty
		draft false // by default this is false
		prerelease false // by default this is false
		releaseAssets getFiles() // this points to which files you want to upload as assets with your release

		overwrite false // by default false; if set to true, will delete an existing release with the same tag and name
		dryRun false // by default false; you can use this to see what actions would be taken without making a release
		apiEndpoint "https://api.github.com" // should only change for github enterprise users
		client // This is the okhttp client used for http requests
	}
} else {
	println("Not configuring GitHub publish because project arguments are missing.")
}

if(project.hasProperty("gameVersion")){
	def gameVersion = project.gameVersion
	def baseVersion = toBaseVersion(gameVersion)
	def files = getFiles(baseVersion)
	def shortest = null
	files.each {
		if(shortest == null || it.name.length() < shortest.name.length()){
			shortest = it
		}
	}
	def extraFiles = files - shortest

	if(curseOK) {
		curseforge {
			apiKey = project.curseToken
			project {
				id = project.curseID
				changelogType = 'markdown'
				changelog = changeLog
				releaseType = 'release'
				addGameVersion gameVersion
				addGameVersion "Forge"

				mainArtifact(file(shortest)) {
					displayName = "${releaseName} ${buildVersion} for Minecraft ${gameVersion}"
				}
				extraFiles.each { addArtifact(it) }
			}
			options {
				debug = false
				javaIntegration = false
				forgeGradleIntegration = false
				javaVersionAutoDetect = false
			}
		}
	} else {
		println("Not configuring CurseForge publish because project arguments are missing.")
	}
	
	if(modrinthOK) {
		modrinth {
			token = project.modrinthToken
			projectId = project.modrinthID
			versionNumber = "$gameVersion-$buildVersion"
			versionName = "$gameVersion-$buildVersion" // the doc says this defaults to the versionNumber, but it defaulted to the string "undefined" for me so i'm setting it
			uploadFile = shortest
			gameVersions = [gameVersion]
			additionalFiles = extraFiles
			loaders = ['forge']
			changelog = changeLog
			detectLoaders = false
		}
	} else {
		println("Not configuring Modrinth publish because project arguments are missing.")
	}
}

def toBaseVersion(ver){
	return String.join(".", ver.tokenize(".").subList(0, 2))
}

def getFiles(ver) {
	def files = []
	new File("${projectDir}/../${ver}/build/libs").eachFile(groovy.io.FileType.FILES, {
		if(!it.name.endsWith("-sources.jar")){
			files << it
		}
	})
	return files
}

def getFiles() {
	def files = []
	project.gameVersions.collect({toBaseVersion(it)}).each {
		files += getFiles(it)
	}
	return files
}

// for debug
task listFiles {
	doLast {
		println(getFiles());
	}
}